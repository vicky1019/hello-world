# encoding:utf-8
# @date:
# @author: vicky
# @environment:
# @brief:


class Expr(object):
    """Abstract class representing expressions"""

    def __init__(self, *args):
        self.children = list(args)
        self.child_values = None

    def eval(self, valuation=None):
        """Evaluates the value of the expression with respect to a given
        variable evaluation."""
        # First, we evaluate the children.
        child_values = [c.eval(valuation=valuation) if isinstance(c, Expr) else c
                        for c in self.children]
        # Then, we evaluate the expression itself.
        if any([isinstance(v, Expr) for v in child_values]):
            # Symbolic result.
            return self.__class__(*child_values)
        else:
            # Concrete result.
            return self.op(*child_values)

    def op(self, *args):
        """The op method computes the value of the expression, given the
        numerical value of its subexpressions.  It is not implemented in
        Expr, but rather, each subclass of Expr should provide its
        implementation."""
        raise NotImplementedError()

    def __repr__(self):
        """Represents the expression as the name of the class, followed by the
        children."""
        return "%s(%s)" % (self.__class__.__name__,
                        ', '.join(repr(c) for c in self.children))

    # Expression constructors

    def __add__(self, other):
        return Plus(self, other)

    def __radd__(self, other):
        return Plus(self, other)

    def __sub__(self, other):
        return Minus(self, other)

    def __rsub__(self, other):
        return Minus(other, self)

    def __mul__(self, other):
        return Multiply(self, other)

    def __rmul__(self, other):
        return Multiply(other, self)

    def __truediv__(self, other):
        return Divide(self, other)

    def __rtruediv__(self, other):
        return Divide(other, self)


class V(Expr):
    """Variable."""

    def __init__(self, *args):
        """Variables must be of type string."""
        assert len(args) == 1
        assert isinstance(args[0], str)
        super().__init__(*args)

    def eval(self, valuation=None):
        """If the variable is in the evaluation, returns the
        value of the variable; otherwise, returns the expression."""
        if valuation is not None and self.children[0] in valuation:
            return valuation[self.children[0]]
        else:
            return self


class Plus(Expr):
    def op(self, x, y):
        return x + y


class Minus(Expr):
    def op(self, x, y):
        return x - y


class Multiply(Expr):
    def op(self, x, y):
        return x * y


class Divide(Expr):
    def op(self, x, y):
        return x / y


def check_equal(x, y, msg=None):
    if x != y:
        if msg is None:
            print("Error:")
        else:
            print("Error in", msg, ":")
        print("    Your answer was:", x)
        print("    Correct answer: ", y)
    assert x == y, "%r and %r are different" % (x, y)
    print("Success")


def expr_derivate(self, var):
    """Computes the derivative of the expression with respect to var."""
    partials = [(c.derivate(var) if isinstance(c, Expr) else 0)
                for c in self.children]
    return self.op_derivate(var, partials).eval()

Expr.derivate = expr_derivate

def expr_op_derivate(self, var, partials):
    raise NotImplementedError()

Expr.op_derivate = expr_op_derivate


def plus_op_derivate(self, var, partials):
    return Plus(partials[0], partials[1])

Plus.op_derivate = plus_op_derivate

if __name__ == "__main__":
    e = V('x') + 3
    print(e)
    print(e.eval())
    print(e.eval({'x': 2}))

    e = (V('x') + V('y')) * (2 + V('x'))
    print(e.eval())
    print(e.eval({'x': 4}))